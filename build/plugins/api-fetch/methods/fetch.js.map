{"version":3,"sources":["../../../../src/plugins/api-fetch/methods/fetch.js"],"names":["fetch","PREFIX_LOG","InternalError","message","join","type","url","request","ServiceNotAvailableError","ParseResponseError","TimeoutError","timeout","code","app","name","settings","headers","outerHeaders","prefix","ssh","agent","log","trace","username","host","port","debug","on","error","route","api","transport","msg","body","meta","useAgent","origin","getSignTransport","getSignRequest","options","method","duration","promise","e","handleError","then","handleSuccess","sign","time","response","resolve","reject","json","status","result","Error","warn","typeof","id","erropt","printError"],"mappings":"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","file":"fetch.js","sourcesContent":["import WrappedError from 'error/wrapped';\nimport TypedError from 'error/typed';\nimport jwt from 'jsonwebtoken';\nimport middleware from 'node-fetch';\nimport { clear } from './../../../utils/make-request';\nimport {\n  API_TIMEOUT,\n  CLIENT_SECRET,\n  CLIENT_TRANSPORT_HEADER,\n  CLIENT_REQUEST_HEADER,\n  CLIENT_PREFIX,\n  CLIENT_CONTENT_TYPE,\n  RESPONSE_PROPERTY_STATUS,\n  RESPONSE_PROPERTY_RESULT,\n  RESPONSE_STATUS_SUCCESS\n} from './../constants';\n\nconst PREFIX_LOG = 'micro.plugins.fetch';\n\nconst InternalError = WrappedError({\n  message: [\n    '{name}: Внутренняя ошибка по запросу [{request}]{url}',\n    '{name}: {origMessage}',\n  ].join('\\n'),\n  type   : `${ PREFIX_LOG }.internal`,\n  url    : null,\n  request: null\n});\n\nconst ServiceNotAvailableError = WrappedError({\n  message: [\n    '{name}: Сервис недоступен по запросу [{request}]{url}',\n    '{name}: {origMessage}',\n  ].join('\\n'),\n  type   : `${ PREFIX_LOG }.service.not.available`,\n  url    : null,\n  request: null\n});\n\nconst ParseResponseError = WrappedError({\n  message: [\n    '{name}: Ошибка парсинга ответа по запросу [{request}]{url}',\n    '{name}: {origMessage}',\n  ].join('\\n'),\n  type   : `${ PREFIX_LOG }.parse.response`,\n  url    : null,\n  request: null\n});\n\nconst TimeoutError = TypedError({\n  message: '{name}: Превышено время ожидания (timeout={timeout}) запроса [{request}]{url}',\n  type   : `${ PREFIX_LOG }.timeout`,\n  timeout: API_TIMEOUT,\n  code   : 504\n});\n\nexport default function fetch(app, { name, settings }) {\n  let {\n    url,\n    headers:outerHeaders = {},\n    prefix = CLIENT_PREFIX,\n    ssh,\n    agent\n  } = settings;\n\n  if (agent) {\n    app.log.trace(`Используется SSH TUNNEL: ${ ssh.username }@${ ssh.host }:${ ssh.port }`);\n    app.log.debug('Настройки SSH TUNNEL:', ssh);\n    agent.on('error', error => app.log.error(WrappedError({\n      message: '{name}: {origMessage}',\n      type   : 'micro.plugin.fetch.ssh.internal'\n    })(error)));\n  }\n\n  return (request, route) => {\n    const { api, transport, ...msg } = request;\n    const body = clear(msg);\n    const meta = {\n      api,\n      transport,\n      request : request.request,\n      useAgent: !!agent\n    };\n    const headers = {\n      'Content-Type': CLIENT_CONTENT_TYPE,\n      'Referer'     : app.name,\n      'User-Agent'  : transport.origin,\n      ...outerHeaders,\n\n      [ CLIENT_TRANSPORT_HEADER ]: getSignTransport(transport),\n      [ CLIENT_REQUEST_HEADER ]  : getSignRequest(meta.request)\n    };\n    const options = {\n      agent,\n      headers,\n      method : 'POST',\n      timeout: API_TIMEOUT,\n      body   : JSON.stringify(body)\n    };\n    request.duration();\n    request.log.trace(`${ PREFIX_LOG }.in`, { body, ...meta });\n\n    let promise;\n\n    try {\n      promise = middleware(url + prefix, options);\n    } catch (e) {\n      return handleError(request, meta)(e);\n    }\n\n    return promise.then(\n      handleSuccess(request, meta),\n      handleError(request, meta)\n    );\n  };\n}\n\nfunction getSignTransport({ ...transport } = {}) {\n  return jwt.sign({ transport: { ...transport } }, CLIENT_SECRET);\n}\n\nfunction getSignRequest({ time, ...request } = {}) {\n  return jwt.sign({ request: { ...request } }, CLIENT_SECRET);\n}\n\nfunction handleSuccess(request, meta) {\n  return response => new Promise(async (resolve, reject) => {\n    try {\n      const json = await response.json();\n\n      // Если ответ корректно распарсился\n      // Разберем ответ - данная структура обязательна для клиентских ответов\n      const {\n        [ RESPONSE_PROPERTY_STATUS ]:status,\n        [ RESPONSE_PROPERTY_RESULT ]:result\n      } = (json || {});\n\n      // Если статус результата - успех, то завершим работу вернув результат\n      if (status === RESPONSE_STATUS_SUCCESS) {\n        request.duration();\n        request.log.trace(`${ PREFIX_LOG }`, meta);\n        return resolve(result);\n      }\n\n      // Если результат не строка и не Error - сообщим о не поддерживаемой ошибке\n      if (typeof result !== 'string' && !(result instanceof Error)) {\n        request.log.warn('Возвращается ошибка в не поддерживаемом формате', {\n          result,\n          typeof   : typeof result,\n          transport: request.transport,\n          request  : request.request,\n        });\n      }\n\n      // Если статус результата - ошибка, то вызовем обработчик ошибок\n      return reject(typeof result !== 'string' ? result : new Error(result));\n    } catch (e) {\n      // Если ошибка парсинга - вызовем обработчик ошибок\n      const { url } = meta;\n      const error = ParseResponseError(e, { url, request: request.request.id });\n\n      request.duration();\n      request.log.error(error.message, { error, ...meta });\n      return reject(result);\n    }\n  });\n}\n\nfunction handleError(request, meta) {\n  return e => new Promise((resolve, reject) => {\n    const erropt = { url: meta.url, request: request.request.id };\n    let printError = true;\n    let error;\n\n    if (e.name === 'FetchError') {\n      switch (e.type) {\n        // Возникает при таймауте запроса\n        case 'request-timeout': {\n          printError = false;\n          error = TimeoutError(erropt);\n          break;\n        }\n        default: error = InternalError(new Error(e.message), erropt);\n      }\n    } else {\n      switch (e.code) {\n        // Возникает когда нет сервиса к которому обращаемся\n        case 'ECONNREFUSED': error = ServiceNotAvailableError(e, erropt);\n          break;\n        default: error = InternalError(e, erropt);\n      }\n    }\n    request.duration();\n\n    if (printError) {\n      request.log.error(error.message, meta);\n    }\n\n    reject(error);\n  });\n}"]}