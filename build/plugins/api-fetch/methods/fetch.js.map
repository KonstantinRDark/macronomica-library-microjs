{"version":3,"sources":["../../../../src/plugins/api-fetch/methods/fetch.js"],"names":["fetch","ERROR_CODE_PREFIX","app","name","settings","url","headers","prefix","ssh","agent","log","trace","username","host","port","debug","on","error","fingerprint","callback","request","route","Promise","resolve","reject","api","transport","req","msg","method","timeout","sign","id","body","JSON","stringify","then","handleSuccess","handleError","response","_handleError","json","status","result","code","details","Error","e","message"],"mappings":"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","file":"fetch.js","sourcesContent":["import jwt from 'jsonwebtoken';\nimport middleware from 'node-fetch';\nimport { clear } from './../../../utils/make-request';\nimport {\n  API_TIMEOUT,\n  CLIENT_SECRET,\n  CLIENT_TRANSPORT_HEADER,\n  CLIENT_REQUEST_HEADER,\n  CLIENT_PREFIX,\n  CLIENT_CONTENT_TYPE,\n  RESPONSE_PROPERTY_STATUS,\n  RESPONSE_PROPERTY_RESULT,\n  RESPONSE_STATUS_SUCCESS,\n  RESPONSE_STATUS_ERROR\n} from './../constants';\n\nconst ERROR_CODE_PREFIX = 'error.http.client';\n\nexport default function fetch(app, { name, settings }) {\n  let {\n    url,\n    headers = {},\n    prefix = CLIENT_PREFIX,\n    ssh,\n    agent\n  } = settings;\n\n  if (agent) {\n    app.log.trace(`Используется SSH TUNNEL: ${ ssh.username }@${ ssh.host }:${ ssh.port }`);\n    app.log.debug('Настройки SSH TUNNEL:', ssh);\n    agent\n      .on('error', app.log.error)\n      .on('verify', (fingerprint, callback) => {\n        app.log.trace(`Server fingerprint is ${ fingerprint }`);\n        callback(); // pass an error to indicate a bad fingerprint\n      });\n  }\n\n  return (request, route) => new Promise((resolve, reject) => {\n    const { api, transport, request:req, ...msg } = request;\n\n    middleware(url + prefix, {\n      agent,\n      method : 'POST',\n      timeout: API_TIMEOUT,\n      headers: {\n        'Content-Type': CLIENT_CONTENT_TYPE,\n        ...headers,\n        \n        [ CLIENT_TRANSPORT_HEADER ]: jwt.sign({ transport }, CLIENT_SECRET),\n        [ CLIENT_REQUEST_HEADER ]  : jwt.sign({ request: { id: req.id } }, CLIENT_SECRET)\n      },\n      body: JSON.stringify(clear(msg))\n    })\n      .then(\n        handleSuccess(app, { request, resolve, reject }),\n        handleError(app, { request, reject })\n      );\n  });\n}\n\nfunction handleSuccess(app, { request, resolve, reject }) {\n  return response => {\n    const _handleError = handleError(app, { request, reject });\n\n    response\n      .json()\n      .then(\n        // Если ответ корректно распарсился\n        (json = {}) => {\n          // Разберем ответ - данная структура обязательна для клиентских ответов\n          const {\n            [ RESPONSE_PROPERTY_STATUS ]:status,\n            [ RESPONSE_PROPERTY_RESULT ]:result\n          } = json;\n\n          // Если статус результата - успех, то завершим работу вернув результат\n          if (status === RESPONSE_STATUS_SUCCESS) {\n            return resolve(result);\n          }\n\n          // Если статус результата - ошибка, то вызовем обработчик ошибок\n          if (status === RESPONSE_STATUS_ERROR) {\n            return _handleError(result);\n          }\n\n          // Если что-то непонятное - вызовем обработчик с ошибкой\n  \n          app.log.error('Ответ клиента неизвестной структуры', {\n            error: {\n              code   : `${ ERROR_CODE_PREFIX }/unknown.response.structure`,\n              details: json\n            }\n          });\n          return reject(new Error(`${ ERROR_CODE_PREFIX }/unknown.response.structure`));\n        },\n        // Если ошибка парсинга - вызовем обработчик ошибок\n        _handleError\n      );\n  };\n}\n\nfunction handleError(app, { request, reject }) {\n  return e => {\n    app.log.error(e);\n    let error;\n\n    switch (e.code) {\n      // Возникает когда нет сервиса к которому обращаемся\n      case 'ECONNREFUSED':\n        error = {\n          code   : `${ ERROR_CODE_PREFIX }/service.not.available`,\n          message: `Клиент по запросу (${ request.id }) недоступен`\n        };\n        break;\n      default: error = e;\n    }\n\n    reject(error);\n  };\n}"]}