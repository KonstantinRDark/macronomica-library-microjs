{"version":3,"sources":["../../../../src/plugins/api-fetch/methods/fetch.js"],"names":["fetch","ERROR_TYPE","InternalError","message","join","type","url","request","ServiceNotAvailableError","ParseResponseError","TimeoutError","timeout","code","app","name","settings","headers","outerHeaders","prefix","ssh","agent","log","trace","username","host","port","debug","on","error","route","api","transport","msg","meta","body","useAgent","origin","getSignTransport","getSignRequest","options","method","then","handleSuccess","handleError","e","sign","time","response","resolve","reject","json","status","result","id","erropt"],"mappings":"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","file":"fetch.js","sourcesContent":["import WrappedError from 'error/wrapped';\nimport TypedError from 'error/typed';\nimport jwt from 'jsonwebtoken';\nimport middleware from 'node-fetch';\nimport { clear } from './../../../utils/make-request';\nimport {\n  API_TIMEOUT,\n  CLIENT_SECRET,\n  CLIENT_TRANSPORT_HEADER,\n  CLIENT_REQUEST_HEADER,\n  CLIENT_PREFIX,\n  CLIENT_CONTENT_TYPE,\n  RESPONSE_PROPERTY_STATUS,\n  RESPONSE_PROPERTY_RESULT,\n  RESPONSE_STATUS_SUCCESS\n} from './../constants';\n\nconst ERROR_TYPE = 'micro.plugin.fetch';\n\nconst InternalError = WrappedError({\n  message: [\n    '{name}: Внутренняя ошибка по запросу [{request}]{url}',\n    '{name}: {origMessage}',\n  ].join('\\n'),\n  type   : `${ ERROR_TYPE }.internal`,\n  url    : null,\n  request: null\n});\n\nconst ServiceNotAvailableError = WrappedError({\n  message: [\n    '{name}: Сервис недоступен по запросу [{request}]{url}',\n    '{name}: {origMessage}',\n  ].join('\\n'),\n  type   : `${ ERROR_TYPE }.service.not.available`,\n  url    : null,\n  request: null\n});\n\nconst ParseResponseError = WrappedError({\n  message: [\n    '{name}: Ошибка парсинга ответа по запросу [{request}]{url}',\n    '{name}: {origMessage}',\n  ].join('\\n'),\n  type   : `${ ERROR_TYPE }.parse.response`,\n  url    : null,\n  request: null\n});\n\nconst TimeoutError = TypedError({\n  message: '{name}: Превышено время ожидания (timeout={timeout}) запроса [{request}]{url}',\n  type   : `${ ERROR_TYPE }.timeout`,\n  timeout: API_TIMEOUT,\n  code   : 504\n});\n\nexport default function fetch(app, { name, settings }) {\n  let {\n    url,\n    headers:outerHeaders = {},\n    prefix = CLIENT_PREFIX,\n    ssh,\n    agent\n  } = settings;\n\n  if (agent) {\n    app.log.trace(`Используется SSH TUNNEL: ${ ssh.username }@${ ssh.host }:${ ssh.port }`);\n    app.log.debug('Настройки SSH TUNNEL:', ssh);\n    agent.on('error', error => app.log.error(WrappedError({\n      message: '{name}: {origMessage}',\n      type   : 'micro.plugin.fetch.ssh.internal'\n    })(error)));\n  }\n\n  return (request, route) => {\n    const { api, transport, ...msg } = request;\n    const meta = {\n      api,\n      route,\n      request : request.request,\n      body    : clear(msg),\n      url     : url + prefix,\n      useAgent: !!agent,\n      timeout : API_TIMEOUT\n    };\n    const headers = {\n      'Content-Type': CLIENT_CONTENT_TYPE,\n      'Referer'     : app.name,\n      'User-Agent'  : transport.origin,\n      ...outerHeaders,\n\n      [ CLIENT_TRANSPORT_HEADER ]: getSignTransport(transport),\n      [ CLIENT_REQUEST_HEADER ]  : getSignRequest(meta.request)\n    };\n    const options = {\n      agent,\n      headers,\n      method : 'POST',\n      timeout: API_TIMEOUT,\n      body   : JSON.stringify(meta.body)\n    };\n\n    try {\n      return middleware(url + prefix, options).then(\n        handleSuccess(request, meta),\n        handleError(request, meta)\n      );\n    } catch (e) {\n      return handleError(request, meta)(e);\n    }\n  };\n}\n\nfunction getSignTransport({ ...transport } = {}) {\n  return jwt.sign({ transport: { ...transport } }, CLIENT_SECRET);\n}\n\nfunction getSignRequest({ time, ...request } = {}) {\n  return jwt.sign({ request: { ...request } }, CLIENT_SECRET);\n}\n\nfunction handleSuccess(request, meta) {\n  return response => new Promise(async (resolve, reject) => {\n    try {\n      const json = await response.json();\n\n      // Если ответ корректно распарсился\n      // Разберем ответ - данная структура обязательна для клиентских ответов\n      const {\n        [ RESPONSE_PROPERTY_STATUS ]:status,\n        [ RESPONSE_PROPERTY_RESULT ]:result\n      } = (json || {});\n\n      // Если статус результата - успех, то завершим работу вернув результат\n      if (status === RESPONSE_STATUS_SUCCESS) {\n        return resolve(result);\n      }\n\n      // Если статус результата - ошибка, то вызовем обработчик ошибок\n      return reject(result);\n    } catch (e) {\n      // Если ошибка парсинга - вызовем обработчик ошибок\n      const { url } = meta;\n      const error = ParseResponseError(e, { url, request: request.request.id });\n      request.log.error(error.message, { error, ...meta });\n      return reject(result);\n    }\n  });\n}\n\nfunction handleError(request, meta) {\n  return e => new Promise((resolve, reject) => {\n    const erropt = { url: meta.url, request: request.request.id };\n    let error;\n\n    if (e.name === 'FetchError') {\n      switch (e.type) {\n        // Возникает при таймауте запроса\n        case 'request-timeout': error = TimeoutError(erropt); break;\n      }\n    }\n\n    switch (e.code) {\n      // Возникает когда нет сервиса к которому обращаемся\n      case 'ECONNREFUSED': error = ServiceNotAvailableError(e, erropt);\n        break;\n      default: error = InternalError(e, erropt);\n    }\n\n    request.log.error(error.message, meta);\n    reject(error);\n  });\n}"]}